<!-- Repository-specific Copilot instructions for AI coding agents -->
# Copilot instructions — MINI_PROJECT

This file contains concise, actionable guidance for AI coding agents working on this STM32-based DSP exercise repository.

- **Project purpose:** : Machine Health Indicator using STM32L4 HAL. The code acquires microphone samples via DFSDM+DMA, computes RFFT (CMSIS DSP), and detects anomalies in machine noise patterns. Results are printed on UART2. Main application logic is in [Core/Src/machine_health.c](Core/Src/machine_health.c).

- **Build system / toolchain:** : Uses CMake + Ninja with an ARM cross toolchain. See [CMakeLists.txt](CMakeLists.txt) and toolchain helpers in [cmake/gcc-arm-none-eabi.cmake](cmake/gcc-arm-none-eabi.cmake). Use the CMake presets in `CMakePresets.json` for standard invocations.

- **Common build commands:**

  - Configure (Debug): `cmake --preset Debug`
  - Build: `cmake --build build/Debug --config Debug` (or `ninja -C build/Debug`)

- **Where to edit:** : Most auto-generated CubeMX code lives under `Core/` (Inc + Src) and `Startup/`. Respect `/* USER CODE BEGIN */` / `/* USER CODE END */` regions — put custom logic inside them to avoid being overwritten by CubeMX.

- **Key source files:**

  - Application entry and peripheral init: [Core/Src/main.c](Core/Src/main.c)
  - Machine Health logic: [Core/Src/machine_health.c](Core/Src/machine_health.c) and [Core/Inc/machine_health.h](Core/Inc/machine_health.h)
  - HAL/CMSIS drivers: [Drivers/STM32L4xx_HAL_Driver](Drivers/STM32L4xx_HAL_Driver)
  - Third-party DSP libs: [Libs/CMSIS_DSP](Libs/CMSIS_DSP)

- **Runtime / debug patterns:** : `printf` is used to emit results via UART2 — check `Core/Src/main.c` and `syscalls.c` for retargeting. The system performs periodic checks with a 5-second sleep interval using `HAL_PWR_EnterSLEEPMode`.

- **Concurrency / callbacks:** : DMA + DFSDM are used to acquire mic samples. The HAL callback `HAL_DFSDM_FilterRegConvCpltCallback` sets a `volatile bool` flag (`mic_dma_finished` in `main.c`) that the main task polls. Use/maintain this pattern when changing acquisition logic.

- **Code conventions & patterns to follow:**

  - Keep hardware init code in generated `MX_*` functions; place algorithmic code in `Core/Src/machine_health.c`.
  - Prefer adding helpers in `Core/Inc` and include headers from existing modules.
  - Use fixed-size buffers defined close to their use (see `INPUT_SIZE` in `machine_health.c`). Be mindful of stack vs. static allocation on embedded targets.
  - Anomaly detection is handled by `detect_anomaly`, which conditionally calls `decompose_spectrum` (CMSIS-DSP) or `expensive_decompose_spectrum` (manual DFT) based on a switch flag.
  - Sample rate is configured for 100Hz with a 100-sample buffer (1s) to allow for performance comparison of $O(N^2)$ algorithms.
  - Use `bool` for flags and status variables where appropriate.

- **Tests / verification:** : No unit tests provided. Verify changes on hardware (UART output) or by adding host-side small test harnesses that simulate input buffers.

- **What not to change:** : Avoid editing autogenerated CubeMX files outside USER CODE blocks (initialization, clock config, pin mapping, startup assembler, and linker scripts in the repo root). If a systemic change is needed, prefer regenerating CubeMX with a new project or adding wrapper layers.

- **Useful examples to reference in repo:**

  - DMA acquisition + callback: [Core/Src/main.c](Core/Src/main.c#L1-L200)
  - Anomaly detection stub: [Core/Src/machine_health.c](Core/Src/machine_health.c)

- **If you create new files:** : Update `CMakeLists.txt` at the project root or the appropriate add_subdirectory to ensure the file is built for both Debug and Release presets.

- **When proposing patches:** : Keep changes minimal, add tests or a short validation note (how to reproduce on hardware), and prefer edits inside `Core/` for algorithmic work.

If any part of the hardware setup, build presets, or CubeMX configuration is unclear, ask for the preferred target preset (Debug/Release) and whether flashing/debugging will be done on local hardware (ST-Link) or via CI.
